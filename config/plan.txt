================================================================================
TRADING SYSTEM PROJECT - PLAN & PROGRESS
================================================================================
Generated: October 17, 2025
Last Updated: November 7, 2025, 10:00 AM EST

================================================================================
PART 1: WHAT WE'VE BUILT SO FAR
================================================================================

COMPLETED COMPONENTS (UPDATED):
├── Base Interfaces & Abstractions
│   ├── BaseDataProvider (abstract class)
│   ├── BaseBroker (abstract class) ✓ Updated with get_order_details()
│   └── BaseStrategy (abstract class)
│
├── Data Providers
│   ├── StockDataProvider (with real-time quote pricing)
│   ├── CryptoDataProvider (with real-time quote pricing)
│   └── Both validated with LatestQuoteRequest ✓
│
├── Broker Implementations
│   ├── AlpacaBroker ✓ Phase 4 Enhanced
│   │   ├── buy(symbol, qty, latest_price) - Now accepts price for validation
│   │   ├── sell(symbol, qty) - Unchanged for now, can be updated
│   │   ├── _wait_for_fill() - Polls and auto-cancels unfilled orders after timeout
│   │   ├── Skips crypto orders < $10 notional value before submission
│   │   ├── get_order_details() - Extracts actual fills with fee logic
│   │   ├── _get_position_qty() - Gets actual position with retries
│   │   ├── _snapshot_position() - Records pre-order position
│   │   ├── _normalize_symbol() - Converts "XRP/USD" to "XRPUSD"
│   │   ├── _is_crypto() - Detects crypto by "/" in symbol
│   │   ├── _get_time_in_force() - Returns GTC for crypto, DAY for stocks
│   │   └── Handles Alpaca-specific fees (0.25% taker for crypto)
│   │
│   └── AlpacaClient (low-level wrapper)
│       ├── TradingClient for paper/live trading
│       ├── HistoricalDataClient for data
│       └── Handles environment variables (API_KEY, SECRET, BASE_URL)
│
├── Position Sizing & Risk Management ✓ Updated Understanding
│   ├── RiskConfig parameters clarified:
│   │   ├── risk_per_trade: Percentage of account equity for sizing
│   │   ├── max_position_size: A hard **quantity** cap, not a percentage
│   │   └── Default max_position_size increased to prevent unintended order capping
│   │
│   └── PositionManager
│       ├── calculate_position_size() - Logic validated
│       └── All other methods unchanged
│
├── Strategies
│   ├── SimpleSMA (Simple Moving Average crossover)
│   │   ├── evaluate_signal(bars=None) - Returns "buy", "sell", "hold"
│   │   └── ✓ Fully integrated and running in live paper trading
│   │
│   └── TestStrategy ✓ Phase 3 Complete
│       ├── Deterministic signals for pipeline validation
│       └── Used for local debugging of broker enhancements
│
├── Trading Engine ✓ Phase 4 Enhanced
│   ├── _execute_strategy(config)
│   │   ├── ✓ Passes latest_price to broker.buy() for consistent validation
│   │   └── ✓ Handles None response from broker for skipped/cancelled orders
│   ├── Graceful error handling validated with real API errors
│   ├── All other components (Scheduler, Logger, etc.) unchanged and stable
│   └── Live paper trading running on Oracle Cloud
│
└── Cloud Deployment
    ├── ✓ Oracle Cloud Always-Free instance running Ubuntu
    ├── ✓ nohup background process confirmed running 24/7
    ├── ✓ SSH key-based access and local alias configured
    └── ✓ Real-time log tailing to logs/live_*.log validated

PHASE 3 COMPLETION SUMMARY:
==========================

WHAT WAS ACCOMPLISHED:

1. Trading Engine Architecture
   - Multi-strategy, multi-symbol support
   - Concurrent execution in background thread
   - Scheduler for market hours + crypto 24/7

2. Order Execution (Hardened in Phase 4)
   - Real orders on Alpaca paper account (stocks fill, crypto hangs)
   - Order fill waiting now includes auto-cancellation for hung orders
   - Added pre-submission validation to skip crypto orders < $10 notional
   - Position delta calculation for actual fills remains robust

3. Price Accuracy
   - LatestQuoteRequest provides real-time ask/bid prices
   - Engine passes latest price to broker, ensuring consistent data at sizing and execution

4. Position Management
   - Actual filled quantities stored (after fees)
   - Handled `max_position_size` as a quantity cap, adjusting configs for proper sizing

5. Testing & Validation
   - TestStrategy used to validate pipeline and debug broker issues locally
   - Live paper trading on cloud confirmed system stability despite API/environment issues

STATUS: Phase 3 COMPLETE, Phase 4 ONGOING
Deliverable: Production-grade trading engine with robust, fault-tolerant execution logic.
Next: Continue collecting Phase 4 baseline metrics and begin Phase 5 development.

================================================================================
PART 2: THE PLAN GOING FORWARD
================================================================================

PHASE 4: SIMPLESMA LIVE PAPER TRADING (CLOUD DEPLOYMENT)
=========================================================
Goal: Verify SimpleSMA works in live paper trading environment
      Validate system stability and extensibility
      (NOT about validating edge - that comes later)

Why this matters:
- Validates extensible architecture before building more strategies
- Establishes baseline metrics for later comparison
- Identifies and resolves real-world execution issues

Key Discoveries & Fixes in Phase 4:
- Alpaca paper trading has known issues filling crypto `qty`-based orders. Our system now gracefully cancels these after a timeout.
- Added a pre-submission check in the broker to skip crypto orders with a notional value under $10, preventing API errors.
- Clarified that `RiskConfig.max_position_size` is a hard quantity cap, not a percentage. Updated configs to allow for proper risk-based sizing.

IMPORTANT - CLOUD + LOCAL PARALLEL DEVELOPMENT:
- SimpleSMA runs 24/7 on the cloud server, validating the hardened architecture with live data.
- Meanwhile, develop Phase 5 strategies (RSI, MACD) LOCALLY in parallel.

Tasks:

4.1 SimpleSMA Integration & Cloud Deployment ✓ COMPLETE
├── Deployed to Oracle Cloud server
├── Running continuously for several days
├── System stability confirmed, no crashes
├── ✓ Debugged and fixed crypto order/sizing issues

4.2 Baseline Metrics Collection (ONGOING)
├── Log all filled stock trades to CSV
├── Note crypto order cancellation rates
├── Track: win rate, return %, max drawdown for stocks
└── Use as a baseline for future, more complex strategies

4.3 Extensibility Validation ✓ COMPLETE
├── Broker interface successfully updated without breaking the engine
└── Proves the architecture is flexible enough for future enhancements

4.4 System Stability ✓ VALIDATED
├── Runs continuously without errors
├── Gracefully handles API errors and unfilled orders
├── Position tracking and logging remain accurate
└── Scheduler works as expected for stocks vs. crypto hours

Timeline: 1-2 weeks (ongoing)
Deliverable: SimpleSMA running stable, architecture validated, ready for new strategies.

PHASE 5: BUILD ADDITIONAL STRATEGIES (LOCAL + PARALLEL)
========================================================
Goal: Build and validate multiple strategies locally while SimpleSMA runs in paper mode.
Deliverables: 3 – 4 fully tested strategies ready for ensemble deployment.

Current Focus Areas (November 2025)
------------------------------------
✔ Begin immediate work on RSI and MACD strategies locally.  
✔ Extend BacktestEngine to include slippage and commissions.  
✔ Build a local /results directory to store CSV summaries of each strategy.  
✔ Plan lightweight persistence structure (JSON or broker-based recovery) for Phase 7.4.  

Active Tasks
------------
5.1 RSI Strategy (Relative Strength Index)
├── File: src/strategies/rsi_strategy.py  
├── Parameters: period = 14, overbought = 70, oversold = 30  
├── Signal: Buy when RSI < oversold, sell when > overbought  
├── Backtest: tests/backtest/backtest_rsi.py  
├── Output: /results/backtest_rsi.csv  
└── Validate mean‑reversion edge on sideways assets (e.g., XRP, AAPL).

5.2 MACD Strategy (Moving Average Convergence Divergence)
├── File: src/strategies/macd_strategy.py  
├── Parameters: fast = 12, slow = 26, signal = 9  
├── Signal: Buy on bullish crossover, sell on bearish crossover  
├── Backtest: tests/backtest/backtest_macd.py  
└── Trend‑following validation against momentum markets.

5.3 Mean Reversion Strategy
├── File: src/strategies/mean_reversion_strategy.py  
├── Parameters: lookback = 20, threshold = 1.5 × std dev  
├── Logic: Buy when price < (SMA−threshold), sell on reversion to SMA  
└── Contrast performance vs RSI/MACD for ensemble diversity.

5.4 Optional Volatility Breakout (ATR‑based)
— Implement later if time allows.

Local Development Checklist
---------------------------
1. Run all new strategies through enhanced BacktestEngine.  
2. Add CSV reporting of equity curve, P&L, Sharpe ratio.  
3. Compare results side‑by‑side vs SimpleSMA baseline.  
4. Store findings in /results/strategy_comparison.csv.  
5. Design ensemble‑voting logic outline for Phase 6.  
6. Continue monitoring live SimpleSMA on Oracle instance.

Timeline: ≈ 3 weeks (runs parallel with cloud SimpleSMA test)

PHASE 5.5: ADD SLIPPAGE & COMMISSIONS TO BACKTEST (LOCAL)
==========================================================
Goal: Make backtests realistic and comparable to paper/live results.
Status: groundwork started (November 2025)

Immediate Objectives
--------------------
✔ Implement 0.05 – 0.20 % slippage per trade (entry + exit).  
✔ Deduct per‑asset commissions:  
    ‑ Stocks = \$5 per round trip  
    ‑ Crypto = 0.25 % taker fee  
✔ Update BacktestEngine & BacktestResult classes.  
✔ Record settings in config/backtest_settings.json for reuse.  
✔ Re‑run backtests for RSI, MACD, Mean Reversion, and SimpleSMA.  
✔ Save results under /results with timestamped filenames.  

Deliverable: realistic, cost‑adjusted performance metrics for all strategies.

PHASE 5.6: DASHBOARD & ANALYTICS MONITOR (LOCAL + CLOUD)
=========================================================
Goal: Provide a consolidated real‑time and historical overview of system performance,
      replacing manual log inspection with a visual dashboard.

Purpose
-------
- Display current status of each running strategy (signal, position, P&L).
- Visualize historical trade logs, cumulative returns, and drawdown.
- Track key risk metrics (exposure %, daily loss %, open vs closed positions).
- Provide a web‑accessible view from the Oracle Cloud instance.

Scope
-----
✔ Phase 5 prototype — build locally or in a Jupyter/Plotly Dash notebook.  
✔ Phase 6 – 7 — migrate to a lightweight web app served from the cloud VM.

Proposed Architecture
---------------------
1. **Data Source**
   - Pull data from existing `/logs/trades_*.csv` and `broker.get_positions()`.
   - Optional: cache summary metrics in `/logs/summary_state.json`.

2. **Visualization Layer Options**
   ├── **Option A – Jupyter Notebook (Phase 5 Local)**
   │     - Generate plots with matplotlib / plotly.
   │     - KPIs: Total P&L, Win‑rate, Max Drawdown, Sharpe ratio.
   │     - Export HTML summaries to /results/reports/.
   ├── **Option B – Plotly Dash / Streamlit Web App (Phase 6 Cloud)**
   │     - Runs continuously on the Oracle instance (ports 8501 / 8050).
   │     - Displays live positions, cumulative equity curve, recent trading log.
   │     - Automatically refreshes every 60 s.

3. **Core Metrics to Track**
   - Equity curve by strategy and total portfolio.
   - Daily and cumulative P&L.
   - Win rate, average trade duration, average P&L per trade.
   - Open positions summary.
   - Rolling Sharpe ratio & volatility.

4. **Implementation Milestones**
   - Week 1–2 (Parallel with Phase 5 tests):  
     Prototype analytics notebook locally using trade CSVs.  
     Generate comparison charts for RSI, MACD, Mean Reversion vs. SimpleSMA.  
   - Week 3+:  
     Deploy lightweight Dash / Streamlit app to Oracle Cloud (accessible via SSH tunnel or web).  
     Add periodic auto‑refresh and error alerts.
   - Phase 9 upgrade:  
     Integrate live notifications and richer database‑backed analytics.

Dependencies
-------------
- pandas, plotly, streamlit (optional dash)
- matplotlib (for static graphs)
- (optional) scikit‑learn for performance statistics

Deliverables
-------------
- `notebooks/performance_dashboard.ipynb` (local prototype)  
- `/dashboard/app.py` (Dash / Streamlit live app)  
- `/results/daily_report.html` static summary for archived sessions

Outcome
--------
✅ One‑click monitoring of system health and performance directly from the cloud VM.
✅ Serves as groundwork for Phase 9 automatic alerts and visual reporting.

PHASE 6: STRATEGY ENSEMBLE & VOTING (CLOUD DEPLOYMENT)
======================================================
Goal: Combine multiple strategies for better robustness
      Deploy all validated strategies to cloud together
      Run ensemble on real paper trading

Why this is critical:
- Single strategy is risky
- Multiple uncorrelated strategies = stronger edge
- Voting system reduces false signals
- Only deploy ensemble, never single strategy

Prerequisites:
- SimpleSMA validated (Phase 4)
- RSI, MACD, Mean Reversion all tested (Phase 5)
- All strategies profitable on paper
- All strategies passed walk-forward tests
- Backtest vs paper returns match within 5%

Tasks:

6.1 Implement Voting System
├── Create src/engine/strategy_ensemble.py
├── Consensus voting: Execute if 2+ strategies agree
├── Weighted voting: Weight by recent performance
├── Confidence scoring: Only trade high confidence
├── Track individual strategy performance
├── A/B test voting methods
└── Paper trade ensemble for 1 month

6.2 Risk Management for Ensemble
├── Reduce position size if signals conflict
├── Example: SimpleSMA says buy, RSI says sell = skip
├── Track correlation between strategies
├── Diversify across uncorrelated signals
├── Maintain daily loss limits
├── Enforce max positions across all strategies
└── Higher thresholds for entry

6.3 Ensemble Validation
├── Paper trade for 1+ month
├── Measure: ensemble win rate vs individual strategies
├── Compare: returns, drawdown, Sharpe ratio
├── Validate ensemble outperforms single strategy
├── Ensure no correlation issues
├── Test on multiple symbols
└── Only proceed if ensemble is superior

Timeline: 2-3 weeks
Deliverable: Working ensemble with 3+ strategies, paper trading validated


================================================================================
PART 7: FINAL VALIDATION BEFORE REAL MONEY
================================================================================
Goal: Final checks before deploying real money

Tasks:

7.1 Risk Management Checklist
├── Position sizing correct
├── Stop losses trigger automatically
├── Take profits trigger automatically
├── Daily loss limits enforced
├── Max position limits enforced
├── Portfolio correlation checked
└── All documented and tested

7.2 Performance Consistency
├── Ensemble win rate 40%+
├── Positive Sharpe ratio
├── Max drawdown < 20%
├── Return per month consistent
├── No black swan losses
└── Paper traded 1+ month

7.3 Paper vs Backtest Alignment
├── Paper returns within 5% of backtest
├── Win rates consistent
├── Max drawdown consistent
├── No hidden assumptions
└── All metrics validated

7.4 State Persistence & Recovery (NEW)
├── Goal: Ensure positions and system state survive restarts and code updates  
├── Implement lightweight persistence module (Phase 7 addition)
│   ├── Option A: JSON file (`positions_state.json`) storing open positions  
│   ├── Option B: Rebuild from `broker.get_positions()` at startup  
│   └── Option C: SQLite/DB layer added later for scalability  
├── On startup, restore open positions into each strategy’s PositionManager  
├── Validate accuracy of entry price, quantity, and timestamps  
├── Test clean restart during active trades (paper first)  
├── Document recovery workflow for deployment scripts  
└── Deliverable: Engine can restart without losing trade state

Timeline: 1 week (integrate before live trading)
Deliverable: Restart‑safe trading engine ready for real deployment

PHASE 8: REAL MONEY DEPLOYMENT (START SMALL)
==============================================
Goal: Deploy ensemble to live trading with small capital

Critical: Start with ONLY 5% of total capital
├── Never risk all capital at once
├── Prove strategy works first
├── Scale gradually over 3 months
├── Continuous monitoring required

Deployment:
├── Switch: paper-api.alpaca.markets to api.alpaca.markets
├── Update .env with live account
├── Start with $1000-$5000 position size
├── Monitor daily: P&L, trades, drawdown
├── Alert if drawdown > 10%
├── Alert if daily loss > 2%
├── Daily performance reports
└── Weekly performance review

Scaling (if successful):
├── Month 1: 5% of capital ($500-$5000)
├── Month 2-3: 25% of capital ($2500-$25000) if profitable
├── Month 4+: Consider full deployment
└── Never skip risk management

Timeline: Ongoing
Deliverable: Live profitable trading system

================================================================================
PART 9: PERFORMANCE MONITORING & ALERTS
================================================================================
Goal: Monitor live trading and detect issues early

Tasks:
├── Real-time P&L tracking per strategy
├── Daily/weekly performance summaries
├── Alert if drawdown exceeds threshold
├── Alert if strategy performance degrades
├── Email/SMS notifications
├── Dashboard showing live positions
├── Automatic trade logging to database
├── **Persist daily P&L snapshots and open positions for long-term performance tracking**
└── Monthly performance reports

================================================================================
PART 3: TIMELINE SUMMARY
================================================================================

AGGRESSIVE TIMELINE (1-2 months to real money):

Week 1:    Phase 4 - SimpleSMA live paper trading
Week 2-3:  Phase 5 - Build & test 3 new strategies (parallel)
Week 3-4:  Phase 5.5 - Add slippage/commissions, validate backtests
Week 5:    Phase 6 - Ensemble voting system
Week 6:    Phase 6 - Paper trade ensemble (1 month minimum)
Week 7:    Phase 7 - Final validation
Week 8+:   Phase 8 - Real money (5% capital)

CONSERVATIVE TIMELINE (3-4 months):

Month 1:   Phase 4 - SimpleSMA paper trading (full month)
Month 2:   Phase 5 - Build & test strategies
Month 2-3: Phase 5.5 - Realistic backtests, walk-forward validation
Month 3:   Phase 6 - Ensemble voting, paper trading
Month 4:   Phase 7 - Final validation
Month 5+:  Phase 8 - Real money (conservative scaling)

RECOMMENDED: Start aggressive, be flexible
├── Monitor progress weekly
├── Extend Phase 4-5 if issues found
├── Don't rush Phase 6-7 validation
├── Better slow and profitable than fast and broke


================================================================================
PART 4: CRITICAL PATH TO PROFITABILITY
================================================================================

DO NOT SKIP THESE STEPS:

Phase 1: Backtesting framework (DONE)
Phase 2: Risk management (DONE)
Phase 3: Trading engine with TestStrategy (DONE)
Phase 4: SimpleSMA live paper trading (NEXT - 1-2 weeks)
Phase 5: Build 3+ additional strategies (2-3 weeks parallel)
Phase 5.5: Add slippage/commissions, validate (1-2 weeks)
Phase 6: Ensemble voting system (2-3 weeks)
Phase 7: Final validation (1 week)
ONLY THEN: Phase 8 - Real money (5% capital)

RED FLAGS - DO NOT PROCEED IF:
├── SimpleSMA crashes or behaves erratically (Phase 4)
├── Any strategy has >50% win rate in backtest (overfitted)
├── Paper trading significantly worse than backtest
├── Ensemble worse than best individual strategy
├── Positive Sharpe ratio not achieved
├── Max drawdown > 30%
└── Can't document why each trade happened

GREEN FLAGS - SAFE TO PROCEED:
├── SimpleSMA runs stable for 2+ weeks (Phase 4)
├── Multiple strategies profitable on paper
├── Paper results match backtest within 5%
├── Ensemble outperforms individual strategies
├── Positive Sharpe ratio (>0.5)
├── Win rate 40-60% (realistic)
├── Max drawdown < 20%
└── Comprehensive documentation


================================================================================
PART 5: KEY INSIGHT - ARCHITECTURE FIRST, STRATEGY LATER
================================================================================

This project prioritizes:

1. SOLID FOUNDATION (Phases 1-4)
   ├── Architecture that scales
   ├── Risk management automated
   ├── Real-time execution proven
   ├── Easy strategy integration
   └── Extensible design

2. MULTIPLE STRATEGIES (Phases 5-6)
   ├── Don't depend on one signal
   ├── Validate each independently
   ├── Combine via ensemble voting
   ├── Diversified edge = safer
   └── Only deploy proven strategies

3. REALISTIC VALIDATION (Phase 5.5)
   ├── Backtest with real costs
   ├── Paper trading 1+ month
   ├── Walk-forward testing
   ├── Multiple time periods
   └── Consistent results only

4. CONSERVATIVE DEPLOYMENT (Phase 8)
   ├── Start with 5% capital
   ├── Scale gradually
   ├── Continuous monitoring
   ├── Automated alerts
   └── Never skip risk rules

Philosophy: Better to be slow and profitable than fast and broke.


================================================================================
PART 6: DEPENDENCIES & REQUIREMENTS
================================================================================

Current requirements.txt (all installed):
- alpaca-py (for Alpaca API)
- pandas (data manipulation)
- numpy (numerical computing)
- python-dotenv (environment variables)
- pytz (timezone handling)

Will need for Phase 5-7:
- scipy (for statistical calculations - Sharpe ratio, etc.)
- ta-lib or pandas-ta (technical analysis indicators)

Optional (Phase 6+):
- matplotlib or plotly (for charts and reports)
- pytest (for unit testing)
- scikit-learn (for Monte Carlo simulation)


================================================================================
PART 7: HOW TO ADD NEW STRATEGIES
================================================================================

Pattern for adding any new strategy:

Step 1: Create strategy file
src/strategies/my_new_strategy.py

Step 2: Implement BaseStrategy interface

from src.strategies.base_strategy import BaseStrategy

class MyNewStrategy(BaseStrategy):
    def __init__(self, broker, symbol, data_provider):
        super().__init__(broker, symbol)
        self.data = data_provider
    
    def evaluate_signal(self, bars=None):
        # Your indicator logic here
        return "buy", "sell", or "hold"
    
    def execute_trade(self, signal):
        pass  # Not used by TradingEngine

Step 3: Backtest it
python tests/backtest/backtest_my_new_strategy.py

Step 4: Paper trade it
In test_trading_engine.py or new test script:
strategy = MyNewStrategy(broker, "XRP/USD", data_provider)
engine.add_strategy("XRP/USD", strategy, risk_config, position_mgr, ...)
engine.start()

Step 5: Monitor for 2-4 weeks
- Track performance
- Compare vs SimpleSMA
- Check for issues

Step 6: Validate results
- Backtest vs paper trading match?
- Walk-forward test successful?
- Add to ensemble voting?

That's it! The architecture handles the rest.


================================================================================
PART 8: FILES & STRUCTURE
================================================================================

Current (Phase 3-4 ready):
├── src/engine/
│   ├── trading_engine.py
│   ├── scheduler.py
│   ├── trade_logger.py
│   ├── strategy_config.py
│   └── __init__.py
├── src/strategies/
│   ├── base_strategy.py
│   ├── simple_sma.py (Phase 4)
│   └── test_strategy.py
├── src/brokers/
│   ├── alpaca_broker.py
│   ├── base_broker.py
│   └── alpaca_client.py
├── src/data/
│   ├── stock_data_provider.py
│   ├── crypto_data_provider.py
│   └── base_data_provider.py
├── tests/engine/
│   ├── test_trading_engine.py
│   └── test_simplesma_live.py (Phase 4)
└── logs/

Phase 5 additions:
├── src/strategies/
│   ├── rsi_strategy.py (Phase 5)
│   ├── macd_strategy.py (Phase 5)
│   ├── mean_reversion_strategy.py (Phase 5)
│   └── volatility_strategy.py (Phase 5)
├── src/engine/
│   └── strategy_ensemble.py (Phase 6)
├── tests/backtest/
│   ├── backtest_rsi.py
│   ├── backtest_macd.py
│   └── backtest_mean_reversion.py
├── tests/engine/
│   ├── test_ensemble_voting.py
│   └── test_multi_strategy.py
└── results/ (backtest results comparison)


================================================================================
PART 9: WHAT'S NEXT (Phase 4)
================================================================================

Immediate next steps:

1. Continue Live Paper Trading (Phase 4)
   - Let the bot continue running on the cloud to gather more stability data.
   - Monitor stock trades and crypto order cancellations.

2. Begin Local Development (Phase 5)
   - Start building `src/strategies/rsi_strategy.py`.
   - Create a corresponding backtest script in `tests/backtest/`.
   - Implement the `evaluate_signal` logic for RSI.

3. Document and Commit Changes
   - Ensure the recent broker and risk config changes are well-commented.
   - Commit the hardened code to your version control system.

Timeline: Start Phase 5 development immediately, in parallel with Phase 4 monitoring.

================================================================================
PART 10: NOTES FOR FUTURE CONTEXT WINDOWS
================================================================================

Quick Reference:

STATUS: Phase 4 ONGOING
- Engine running live on cloud, architecture hardened.
- Stock trades execute, crypto orders gracefully time out and cancel due to known paper trading issue.
- Risk sizing logic corrected.

NEXT: Phase 5 (NOW, in parallel)
- Build RSI, MACD, and Mean Reversion strategies locally.
- Backtest each new strategy thoroughly.
- Do not deploy new strategies to the cloud until Phase 4 completes and they are validated locally.

Key Files (Updated):
- Engine: src/engine/trading_engine.py (passes latest_price)
- Broker: src/brokers/alpaca_broker.py (validates notional, cancels hung orders)
- Portfolio: src/portfolio/risk_config.py (clarified max_position_size)

Remember:
- `max_position_size` is a QUANTITY cap. Use `risk_per_trade` for percentage-based sizing.
- The broker's `buy()` method now requires `latest_price` for validation.
- Paper crypto orders are unreliable; the system is designed to handle this.